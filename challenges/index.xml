<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Challenges on </title>
    <link>/challenges/</link>
    <description>Recent content in Challenges on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <managingEditor>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</managingEditor>
    <webMaster>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</webMaster>
    <lastBuildDate>Sat, 01 Mar 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="/challenges/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Careful with randomness!</title>
      <link>/challenges/signature-failure/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate><author>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</author>
      <guid>/challenges/signature-failure/</guid>
      <description>&lt;h2 id=&#34;signature-schemes&#34;&gt;Signature schemes&lt;/h2&gt;&#xA;&lt;p&gt;Let &lt;code&gt;ùí¢&lt;/code&gt; be a commutative group under the addition law (&lt;code&gt;+&lt;/code&gt;) and let &lt;code&gt;G ‚àä ùí¢&lt;/code&gt;.&#xA;The group has an order &lt;code&gt;p&lt;/code&gt;. We define a scalar multiplication &lt;code&gt;k*G&lt;/code&gt; as&#xA;&lt;code&gt;G+...+G&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; times. Now assume that given an element &lt;code&gt;Q ‚àä ùí¢&lt;/code&gt; it is&#xA;computationally unfeasible to find &lt;code&gt;k&lt;/code&gt; such that &lt;code&gt;Q = k*G&lt;/code&gt;. We have seen in a&#xA;different challenge that it is easy to go from &lt;code&gt;G&lt;/code&gt; to &lt;code&gt;k*G&lt;/code&gt; but now we are&#xA;assuming that it is hard to go from &lt;code&gt;k*G&lt;/code&gt; to &lt;code&gt;G&lt;/code&gt;. This is called a one-way&#xA;function. In this challenge, we will build a signature scheme based on this&#xA;function.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Witness or liar?</title>
      <link>/challenges/primality-testing/</link>
      <pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate><author>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</author>
      <guid>/challenges/primality-testing/</guid>
      <description>&lt;h2 id=&#34;primality-testing&#34;&gt;Primality testing&lt;/h2&gt;&#xA;&lt;h3 id=&#34;naive-but-deterministic&#34;&gt;Naive but deterministic&lt;/h3&gt;&#xA;&lt;p&gt;Primes are of great theoretical and practical value in cryptography. A&#xA;primality test is an algorithm for determining whether an input number is&#xA;prime. The simplest primality test is trial division: given an input number,&#xA;&lt;code&gt;n&lt;/code&gt;, check whether it is divisible by any prime number between 2 and &lt;code&gt;‚àön&lt;/code&gt;. If&#xA;so, then &lt;code&gt;n&lt;/code&gt; is composite. Otherwise, it is prime.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;The prime number theorem: the distribution of primes is œÄ(n) ~ n/ln(n)&#xA;where œÄ(n) is the prime-counting function (the number of primes less than or&#xA;equal to n) and ln(n) is the natural logarithm of n.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Divide and conquer!</title>
      <link>/challenges/multiplication-complexity/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate><author>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</author>
      <guid>/challenges/multiplication-complexity/</guid>
      <description>&lt;h2 id=&#34;multiplication-algorithms&#34;&gt;Multiplication algorithms&lt;/h2&gt;&#xA;&lt;h3 id=&#34;time-complexity&#34;&gt;Time complexity&lt;/h3&gt;&#xA;&lt;p&gt;The time complexity describes the amount of computer time it takes to run an algorithm. It is estimated by counting the number of elementary operations performed by the algorithm. Since an algorithm&amp;rsquo;s running time may vary among different inputs of the same size, one commonly considers the worst-case time. Algorithmic complexities are classified according to the type of function appearing in the big O notation. Here are some examples:&lt;/p&gt;</description>
    </item>
    <item>
      <title>One step at a time!</title>
      <link>/challenges/scalar-multiplication-complexity/</link>
      <pubDate>Fri, 28 Feb 2025 00:00:00 +0000</pubDate><author>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</author>
      <guid>/challenges/scalar-multiplication-complexity/</guid>
      <description>&lt;h2 id=&#34;scalar-multiplication&#34;&gt;Scalar multiplication&lt;/h2&gt;&#xA;&lt;p&gt;Let &lt;code&gt;ùí¢&lt;/code&gt; be a commutative group under the addition law (&lt;code&gt;+&lt;/code&gt;) and let &lt;code&gt;G ‚àä ùí¢&lt;/code&gt;. We define a scalar multiplication &lt;code&gt;k*G&lt;/code&gt; as &lt;code&gt;G+...+G&lt;/code&gt;, &lt;code&gt;k&lt;/code&gt; times.&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Consider &lt;code&gt;105*G&lt;/code&gt;. How many additions does it involve?&lt;/li&gt;&#xA;&lt;li&gt;Now consider the binary decomposition of &lt;code&gt;105 = 2^6 + 2^5 + 2^3 + 2^0&lt;/code&gt;. It can be written as &lt;code&gt;105 = ((((((((((1 ¬∑ 2 + 1) ¬∑ 2) + 0) ¬∑ 2) + 1) ¬∑ 2) + 0) ¬∑ 2) + 0) ¬∑ 2) + 1&lt;/code&gt;. Given that a doubling (multiplication by 2) has the same cost as an addition, how many additions &lt;code&gt;105*G&lt;/code&gt; involves?&lt;/li&gt;&#xA;&lt;li&gt;What is the complexity of the naive algorithm?&lt;/li&gt;&#xA;&lt;li&gt;Let &lt;code&gt;n&lt;/code&gt; be the number of bits in &lt;code&gt;k&lt;/code&gt;. We can write &lt;code&gt;k = k_0 + 2 k_1 + 2^2 k_2 + ... + 2^{n-1} k_{n-1}&lt;/code&gt; where &lt;code&gt;k_i ‚àä {0,1}&lt;/code&gt;. Can you derive an algorithm for computing &lt;code&gt;k*G&lt;/code&gt; in less than &lt;code&gt;k-1&lt;/code&gt; additions?&lt;/li&gt;&#xA;&lt;li&gt;Assuming that on average half of the &lt;code&gt;k_i&lt;/code&gt;&amp;rsquo;s are 1, how many additions do you need? What is the complexity of your algorithm?&lt;/li&gt;&#xA;&lt;li&gt;We want now to compute &lt;code&gt;k*G1 + k&#39;*G2&lt;/code&gt;. The obvious solution would be to compute &lt;code&gt;k*G1&lt;/code&gt; and &lt;code&gt;k&#39;*G2&lt;/code&gt; separately and add them. Can you do better? &lt;em&gt;Hint: start an accumulator with &lt;code&gt;G1+G2&lt;/code&gt; and scan &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;k&#39;&lt;/code&gt; bits simultaenously&lt;/em&gt;.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://hackmd.io/_uploads/S1QPnhkjyg.jpg&#34; alt=&#34;image&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sometimes answers are hidden in plain sight!</title>
      <link>/challenges/steganography/</link>
      <pubDate>Thu, 27 Feb 2025 00:00:00 +0000</pubDate><author>cipherchallenge@um6p.ma (Cipher Challenge Cryptography Edition)</author>
      <guid>/challenges/steganography/</guid>
      <description>&lt;ol&gt;&#xA;&lt;li&gt;Answers to all the challenges are hidden in the corresponding images. If you revese-engineer the code &lt;a href=&#34;&#34;&gt;here&lt;/a&gt; you&amp;rsquo;ll find them!&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;em&gt;Hint: space is full of pixels and a pixel does not need all the bits!&lt;/em&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
